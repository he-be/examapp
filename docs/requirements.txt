LLM評価テスト体験サイト：システム要件定義書（Cloudflare Workers 統合アーキテクチャ版）




Executive Summary


本文書は、「LLM評価テスト体験サイト」の改訂版システム要件定義書（SRS）である。本プロジェクトの技術基盤を、Cloudflareの最新のプラットフォーム戦略に準拠した、Cloudflare Workersに全面的に統合された最新のフルスタックアーキテクチャへと刷新する。
主要なアーキテクチャ変更点は、静的アセットの配信と動的API処理の両方を単一のCloudflare Workerに統合することにある。この変更は、Cloudflareが公式に推奨する開発モデルを反映したものである。Cloudflareは、これまでCloudflare Pagesが担ってきた領域を含むすべての新規プロジェクトにおいて、Workersの使用を推奨している 1。
この最新アプローチを採用することにより、開発ワークフローの簡素化、デプロイプロセスの一元化、パフォーマンスの向上、そしてプラットフォームの進化に対する将来性の確保といった、多岐にわたる重要な利点が得られる。本文書は、本プロジェクトの実装、デプロイ、そして運用における完全な技術的青写真として機能することを目的とする。
________________


1. プロジェクトビジョンと基本理念




1.1. 目的と背景


本プロジェクトの核心的使命は、MMLUやGSM-8Kといった主要な大規模言語モデル（LLM）評価ベンチマークを、技術的専門知識を持たない一般ユーザーが体験できるインタラクティブなWebプラットフォームを構築することにある。ユーザーがLLMの能力を評価するテストを自ら体験することで、その性能と限界を直感的に理解し、AIリテラシーの向上に貢献することが本サイトの主目的である。
LLMの評価プロセスは、学術論文や技術文書で語られることが多く、一般には不透明な領域である。本サイトは、このプロセスを可視化し、体験可能なものとすることで、LLMへの理解を深める教育的役割を担う。


1.2. アーキテクチャ理念（改訂）


本プロジェクトの技術的基盤を定義するにあたり、以下の基本理念を定める。これは、最新のクラウドインフラストラクチャのベストプラクティスを反映し、プロジェクトの長期的な成功を確実にするためのものである。
理念1：Workers-First 統合アーキテクチャ
アプリケーションのすべてのロジック（コンピューティング、ルーティング、静的・動的コンテンツ配信）を、単一のCloudflare Workerに統合する。これは、静的コンテンツをPagesで、動的機能をFunctionsで処理するという従来のハイブリッドモデルを意図的に排除し、より洗練されたフルスタックアプローチを採用するものである。この決定は、「今後のCloudflareの開発努力はWorkersに集中する」1、「今後のすべての投資、最適化、機能開発はWorkersの改善に専念する」3 というCloudflareの明確な方針に基づいている。この戦略的整合性により、本プロジェクトは将来的なプラットフォームの革新と性能最適化の恩恵を最大限に享受できる。
理念2：ステートレス・バイ・デザイン
ユーザーの状態（テストの進捗、スコアなど）は、サーバーサイドには一切保存せず、クライアントサイドのブラウザストレージ（localStorage）のみで管理する。この設計は、ユーザープライバシーの保護とアーキテクチャの簡潔性を最優先するものである。CloudflareプラットフォームがD1（SQLデータベース）やR2（オブジェクトストレージ）といった強力なステートフルサービスを提供していることを認識した上で 4、本プロジェクトの初期フェーズでは意図的にステートレス設計を選択する。
理念3：グローバル・エッジ・デリバリー
アプリケーションはCloudflareのグローバルネットワークにデプロイされ、世界中のユーザーに対して最小限の遅延でサービスを提供する。静的アセットと動的APIコールの両方が、ユーザーに最も近いエッジロケーションから配信される。これは、Workersプラットフォームが提供する中核的な利点である 6。
なお、Cloudflareの製品群には「Cloudflare Pages」（製品）と「Page Rules」（廃止予定の機能）が存在し、コミュニティで混同が見られることがある 8。開発チーム内での混乱を避けるため、本文書では本プロジェクトのコアコンポーネントを「Cloudflare Workers」として明確に定義し、用語の曖牲さを排除する。
________________


2. ユーザー体験と機能要件


本セクションでは、ユーザーに提供される機能と体験について定義する。

2.1. ターゲットユーザー像


本サイトは、以下の4つの主要なユーザーペルソナを対象とする。
* 一般ユーザー: AIやLLMに興味はあるが、専門知識は持たない層。LLMの能力を直感的に理解したいという動機を持つ。
* 教育関係者: AIに関する授業や教材として本サイトを活用することを想定。生徒のAIリテラシー向上を目指す。
* 開発者・研究者: LLM評価の補助ツールとして、あるいはベンチマークの内容を迅速に確認する目的で利用する。
* 学生: AIやコンピュータサイエンスを学ぶ学生が、実践的な体験学習の一環として利用する。


2.2. UIとインタラクションフロー


* ナビゲーション: トップページから各ベンチマークテストへ、ワンクリックでアクセス可能な、クリーンで直感的なナビゲーションを提供する。
* 体験モード:
   * 練習モード: 時間制限なし。各問題に対して即座にフィードバックと詳細な解説が表示される。
   * テストモード: 時間制限あり。セッション終了後に最終的なスコアサマリーが表示される。このモード中の状態は、localStorageを用いてセッション内で管理される。
* 結果表示: テスト完了後、ユーザーの正答率、所要時間を表示する。さらに、主要なLLMモデルの公開平均スコアとの比較を提示し、ユーザー自身のパフォーマンスを客観的に把握できるよう支援する。
* 復習機能: ユーザーが間違えた問題を確認できる機能を提供する。この機能に必要なデータは、localStorageのセッションオブジェクトから取得する。


2.3. ベンチマークテストモジュール（機能仕様）


以下の5つの主要ベンチマークについて、それぞれの問題形式、ユーザーインタラクション、フィードバック内容を定義する。
* 2.3.1. MMLU (Massive Multitask Language Understanding):
   * 形式: 多肢選択式クイズ
   * 内容: 57の多様な分野（基礎数学、米国の歴史、コンピュータサイエンス、法律など）から出題される。
   * フィードバック: 正解・不正解の表示と共に、なぜその選択肢が正しいのかを簡潔に解説する。
* 2.3.2. GSM-8K (Grade School Math 8K):
   * 形式: 文章問題に対する数値入力
   * 内容: 小学校レベルの算数知識で解けるが、多段階の思考・計算を必要とする問題。
   * フィードバック: 正解・不正解に加え、正解に至るまでの中間的な思考ステップ（Chain of Thought）を段階的に解説する。
* 2.3.3. HellaSwag (Hard Endings for Large Language Models):
   * 形式: 文脈に続く最も自然な結末を選択
   * 内容: 日常的なシナリオの文脈を提示し、常識的に最もあり得る続きを選択させる。
   * フィードバック: 正解・不正解と共に、なぜその選択が常識的な推論として適切かを解説する。
* 2.3.4. BIG-Bench-Hard:
   * 形式: 多様なタスク（論理パズル、パターン認識など）
   * 内容: 現在のLLMが特に苦手とする、高度な推論能力を要する23のタスクから代表例を出題。
   * フィードバック: 正解・不正解と共に、そのタスクがAIにとってなぜ難しいのか、その課題の核心を解説する。
* 2.3.5. DROP (Discrete Reasoning Over Paragraphs):
   * 形式: 長文読解に基づく質問応答
   * 内容: 提示された段落を読み、数値計算や日付比較など、テキストから情報を抽出・加工して解答する必要がある問題。
   * フィードバック: 正解・不正解と共に、解答を導き出すために必要だった推論プロセスを解説する。


2.4. 付随機能

* ローカライゼーション: システムは国際化を念頭に置いて設計される。初期リリースでは日本語を主要言語とし、将来的な拡張として英語対応を計画する。


3. システムアーキテクチャと技術仕様




3.1. Cloudflare Workers 統合アーキテクチャ


本プロジェクトのアーキテクチャは、Cloudflare Workersが静的アセット配信機能をネイティブにサポートするようになったことを最大限に活用する 3。これにより、従来はCloudflare PagesとPages Functions（実体はWorkers）という2つのコンポーネントに分離されていたアプリケーションを、単一のCloudflare Workerプロジェクトとして一元管理・デプロイすることが可能となる。この統合モデルは、開発体験を大幅に向上させ、インフラ管理を極限まで簡素化する。
このアーキテクチャ移行の利点を明確化するため、従来のモデルと本プロジェクトで採用する統合モデルを比較する。
表1: アーキテクチャモデル比較


機能
	従来のハイブリッドモデル（Pages + Functions）
	本プロジェクトの統合モデル（Workers-Only）
	設定管理
	wrangler.tomlとPagesのダッシュボード設定が混在
	単一の wrangler.toml ファイルで一元管理
	デプロイ
	廃止予定の pages-action を使用 11
	最新の wrangler-action を使用
	静的アセット配信
	Pagesプラットフォームが暗黙的に処理
	Workersランタイムが wrangler.toml の設定に基づき明示的に処理 1
	APIロジック
	/functions ディレクトリ内のPages Functionsとして実装 12
	Workerの標準的な fetch ハンドラ内でルーティングして実装
	開発体験
	静的サイトとAPIでコンテキストが分離
	フロントエンドとバックエンドが単一プロジェクト内で完結し、統一された体験
	将来性
	Pagesは機能維持が主となり、新機能の追加は限定的
	Cloudflareの全投資が集中するWorkersの進化の恩恵を直接享受 3
	

3.2. コンポーネントとデータフロー


アプリケーションのコンポーネントとリクエストのライフサイクルは以下の通りである。
1. クライアント（ブラウザ）:
   * ReactやVueなどのフレームワークで構築され、静的なHTML/CSS/JSにコンパイルされたUIをレンダリングする。
   * localStorage APIを使用して、ユーザーのテスト進捗やスコアといった全ての状態を管理する。
   * クライアントサイドでの入力検証や正誤判定を行う。
2. エッジ（Cloudflare Worker）:
   * すべてのリクエストに対する単一のエントリーポイントとして機能する。
   * 静的アセットリクエスト: /index.html、/main.js、/style.css、あるいは問題データである /questions/mmlu.json のような静的ファイルへのリクエストは、Cloudflareのランタイムによって自動的に捕捉される。これらのリクエストは、wrangler.tomlで指定されたアセットディレクトリから直接配信され、Workerのメインスクリプト（fetchハンドラ）は実行されない 1。
   * APIリクエスト: POST /api/feedback のような特定のAPIパスへのリクエストは、静的アセットと一致しないため、Workerの fetch ハンドラに渡され、動的な処理が実行される。
3. データ（静的JSON）:
   * すべてのベンチマークの問題、選択肢、解説データは、静的なJSONファイルとしてプロジェクトのアセットディレクトリ内に格納される。
   * これらのファイルはアプリケーションと共にデプロイされ、CloudflareのグローバルCDNを介して配信されるため、極めて低遅延なデータアクセスが実現される。


3.3. 技術スタック


* フロントエンド: HTML, CSS, TypeScript（フレームワークとしてReact, Vue, Svelteなどを推奨）
* バックエンド/配信: Cloudflare Workers (TypeScript)
* 状態管理: Browser localStorage API
* CI/CD: GitHub Actions with wrangler-action
* ビルドツール: wrangler CLI
* 開発環境: Cloudflare Vite Plugin 3 や
wrangler dev を活用
このアーキテクチャはシンプルでありながら、明示的な設定が求められる点に留意が必要である。Cloudflare Pagesは、プロジェクトがシングルページアプリケーション（SPA）であるかどうかをヒューリスティックに「推測」してよしなに振る舞う挙動があった 1。対照的に、統合されたWorkersモデルでは、開発者が
wrangler.toml 内で spa 設定を明示的に指定する必要がある。この「暗黙より明示」という設計思想は、意図しない挙動を防ぎ、システムの堅牢性を高める上で重要である。この設定を怠ると、クライアントサイドのルート（例：/test/mmlu）でページをリロードした際に404エラーが発生するため、正しい設定は不可欠である。
________________


4. 実装ブループリント




4.1. プロジェクト設定 (wrangler.toml)


開発チームが直接利用可能な、本番環境を想定した wrangler.toml の完全な設定ファイルを提供する。各設定パラメータの役割について注釈を付記する。


Ini, TOML




# wrangler.toml

# Workerの名称。Cloudflareダッシュボードで表示される。
name = "llm-test-experience"

# 互換性日付。最新のWorkersランタイム機能を利用するために、最近の日付に設定する。
# 参考: https://developers.cloudflare.com/workers/platform/compatibility-dates/
compatibility_date = "2025-04-08"

# APIロジックなど、動的リクエストを処理するWorkerスクリプトのエントリーポイント。
main = "src/index.ts"

# [site]ブロックはwrangler v3で非推奨となり、[assets]に統合された。
# wrangler v4以降では、静的アセットの設定は[assets]で行うのが標準。
# https://developers.cloudflare.com/workers/wrangler/configuration/#static-assets
[assets]
# ビルドプロセスによって生成された静的フロントエンドアセット（HTML, JS, CSSなど）が含まれるディレクトリ。
directory = "./dist"

# シングルページアプリケーション（SPA）のルーティングを有効にする設定。
# これにより、存在しないパスへのナビゲーションリクエスト（例：/test/mmlu）に対して、
# 404を返す代わりに指定されたファイル（通常はindex.html）を返す。
# これはCloudflare Pagesの「マジック」な挙動を明示的に再現するものである [1]。
spa = "./dist/index.html"

# wrangler devコマンドでローカル開発サーバーを起動する際の設定。
[dev]
# ローカルマシンのポート番号
port = 8787
# ローカルネットワーク上の他のデバイスからのアクセスを許可するかどうか
ip = "0.0.0.0"



4.2. Workerエントリーポイント (src/index.ts)


メインのWorkerスクリプトの構造を示すコードブループリントを提供する。このコードの目的は、APIリクエストを選択的に処理しつつ、その他のリクエストはプラットフォームの静的アセット配信機能に委ねる方法を明確にすることである。


TypeScript




// src/index.ts

// 環境変数などの型定義（必要に応じて）
export interface Env {
   // 例：フィードバック送信用のAPIキーなど
   // SENDGRID_API_KEY: string;
}

export default {
   /**
    * Workerのエントリーポイント。すべてのリクエストがこの関数を通過する。
    * ただし、リクエストが[assets]で設定された静的ファイルに一致する場合、
    * Cloudflareランタイムがこのfetchハンドラを呼び出す前にレスポンスを返す。
    * したがって、このコードは主にAPIエンドポイントのような動的リクエストを処理するために存在する。
    */
   async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
       const url = new URL(request.url);

       // APIルート: /api/feedback へのPOSTリクエストのみを処理
       if (url.pathname === '/api/feedback' && request.method === 'POST') {
           try {
               // リクエストボディをJSONとしてパース
               const feedbackData: { [key: string]: any } = await request.json();
               
               // ここで外部サービス（例: SendGrid, Slack API）にフィードバックを送信するロジックを実装
               // await sendFeedbackToExternalService(feedbackData, env);

               console.log('Feedback received:', feedbackData);

               // 成功レスポンスを返す
               const responseBody = JSON.stringify({ success: true, message: "Feedback received." });
               return new Response(responseBody, {
                   status: 200,
                   headers: { 'Content-Type': 'application/json' },
               });

           } catch (error) {
               // JSONのパース失敗など、リクエストに問題があった場合
               if (error instanceof SyntaxError) {
                   return new Response('Invalid JSON in request body.', { status: 400 });
               }
               // その他のサーバーサイドエラー
               console.error('Error processing feedback:', error);
               return new Response('An internal error occurred.', { status: 500 });
           }
       }

       // このハンドラに到達したということは、リクエストが静的アセットにも
       // 上記のAPIルートにも一致しなかったことを意味する。
       // SPA設定が有効なため、通常はナビゲーションリクエストはここに到達しないが、
       // 不明なAPIエンドポイントへのアクセスなどのためにフォールバックを用意する。
       return new Response('Not Found', { status: 404 });
   },
};



4.3. API仕様


表2: APIエンドポイント仕様 (/api/feedback)
プロパティ
	説明
	エンドポイント
	/api/feedback
	HTTPメソッド
	POST
	リクエストヘッダ
	Content-Type: application/json
	リクエストボディ (JSON)
	`{ "testId": string, "questionId": string, "feedbackText": string, "userScore": number
	成功レスポンス
	コード: 200 OK ボディ: {"success": true, "message": "Feedback received."}
	エラーレスポンス
	コード: 400 Bad Request (リクエストボディが不正な場合) コード: 500 Internal Server Error (サーバー内部エラーの場合)
	

4.4. データ構造


クライアントサイドで管理されるデータ構造を以下に定義する。
   * 問題データ (静的JSON):
当初の定義書に記載された構造を踏襲し、各ベンチマークの問題、選択肢、正解、解説を含むJSONファイルとして /dist/questions/ ディレクトリ配下に配置する。
   * クライアントサイド状態管理 (localStorage):
localStorageに llmTestProgress というキーで保存されるオブジェクトの構造例を以下に示す。
JavaScript
// ユーザー進捗の保存オブジェクト例
const userProgress = {
 currentTest: "mmlu", // 現在進行中のテストID
 startTime: 1678886400000, // テスト開始時刻のタイムスタンプ
 answers: {
   "mmlu_001": {
     "userAnswer": 0, // ユーザーが選択した選択肢のインデックス
     "isCorrect": true
   },
   "gsm8k_001": {
     "userAnswer": "1.67",
     "isCorrect": false
   }
 },
 // テストモード完了後のスコア
 finalScore: {
   correct: 8,
   total: 10,
   percentage: 80,
   timeTaken: 120 // 秒
 }
};

________________


5. 非機能要件




5.1. パフォーマンスとスケーラビリティ


      * ページ表示速度: Largest Contentful Paint (LCP) を2.5秒未満に抑えることを目標とする。これは、すべての静的アセットがCloudflareのグローバルエッジCDNから配信されることで達成される 13。
      * スケーラビリティ: 本アーキテクチャは本質的に高いスケーラビリティを持つ。Cloudflare Workersは、トラフィックの急増に対して自動的にスケールするため、インフラ設定は不要である。また、ステートレス設計により、共有リソースやデータベースのボトルネックが存在せず、スケーリングがさらに簡素化される。


5.2. セキュリティ体制


      * プラットフォームセキュリティ: アプリケーションは、DDoS攻撃からの保護、マネージドWAF（Web Application Firewall）など、Cloudflareの標準的なセキュリティスイートの恩恵を自動的に受ける 4。
      * アプリケーションセキュリティ: ユーザーデータをサーバーに送信・保存しないステートレス設計により、攻撃対象領域（アタックサーフェス）が大幅に削減される。これにより、ユーザープライバシーに関わるデータ漏洩のリスクが構造的に低減される。


5.3. アクセシビリティと互換性


      * アクセシビリティ: Web Content Accessibility Guidelines (WCAG) 2.1の適合レベルAAに準拠することを目指す。スクリーンリーダーへの対応や、色覚多様性への配慮を含む。
      * 互換性: 主要なモダンブラウザ（Chrome, Firefox, Safari, Edge）の最新バージョンに対応する。また、スマートフォンやタブレット端末での利用を想定したレスポンシブデザインを必須とする。
________________


6. デプロイと運用




6.1. CI/CDパイプライン (GitHub Actions)


最新のベストプラクティスに基づいた、自動化されたデプロイパイプラインを構築する。このプロセスでは、廃止が発表された cloudflare/pages-action の代わりに、後継である cloudflare/wrangler-action を使用することが必須である 11。
以下に、GitHub Actionsで使用するワークフローファイルの完全なサンプルを提供する。このファイルは、コードのチェックアウト、依存関係のインストール、フロントエンドのビルド、そしてwrangler-actionを使用したCloudflare Workersへのデプロイまでの一連の流れを自動化する。


YAML




#.github/workflows/deploy.yml

name: Deploy to Cloudflare Workers

on:
 push:
   branches:
     - main # mainブランチへのプッシュをトリガーとする

jobs:
 deploy:
   runs-on: ubuntu-latest
   name: Deploy
   steps:
     - name: Checkout
       uses: actions/checkout@v4

     - name: Setup Node.js
       uses: actions/setup-node@v4
       with:
         node-version: '20' # プロジェクトで使用するNode.jsのバージョンを指定

     - name: Install dependencies
       run: npm install

     - name: Build application
       run: npm run build # フロントエンドのビルドコマンドを実行

     - name: Publish to Cloudflare Workers
       # wrangler-actionは、wrangler CLIのラッパーとして機能する
       # https://github.com/cloudflare/wrangler-action
       uses: cloudflare/wrangler-action@v3
       with:
         # GitHubリポジトリのSecretsに 'CLOUDFLARE_API_TOKEN' という名前で
         # Cloudflare APIトークンを保存する必要がある
         apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
         # CloudflareアカウントIDもSecretsに保存することを推奨
         accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
         # wrangler.tomlで定義されたWorker名
         # projectName: "llm-test-experience" # wrangler.tomlから自動で読み込まれるため通常は不要

wrangler-actionへの移行は必須であるが、pages-actionとは構文が異なり、また移行期においては一部機能（例：過去のデプロイメント一覧のUI表示）に差異が生じる可能性がある点に留意する必要がある 11。このワークフローファイルを提供することで、実装チームはCI/CD設定のリスクを低減し、スムーズに最新のデプロイ手法へ移行できる。


6.2. 監視とオブザーバビリティ


Cloudflareプラットフォームが提供する組み込みの監視ツールを活用し、アプリケーションの健全性を維持する 3。
      * トラフィックとパフォーマンス: Cloudflareダッシュボードの「Analytics」機能を使用して、リクエスト数、帯域幅、キャッシュヒット率などの基本的なメトリクスを監視する。また、Web Vitalsの計測により、実際のユーザー体験に基づいたパフォーマンスを把握する。
      * エラーとログ: APIエンドポイントで発生したエラーや console.log の出力は、Cloudflareダッシュボードの「Workers Logs」で確認できる。また、ローカル開発時と同様に wrangler tail コマンドを使用することで、本番環境のログをリアルタイムでストリーミング受信でき、迅速なデバッグが可能となる 14。
________________


7. 制約と将来のロードマップ




7.1. ステートレス設計の制約


本プロジェクトのV1（バージョン1）で採用するステートレスアーキテクチャは、シンプルさとプライバシー保護の観点から多くの利点を持つが、その設計思想に起因する機能的な制約も存在する。これらのトレードオフを明確に認識しておくことが重要である。
      * クロスデバイス同期の不可: ユーザーの進捗はブラウザのlocalStorageに保存されるため、デスクトップで開始したテストをモバイルデバイスで引き継ぐことはできない。
      * 永続的なユーザーアカウントの不在: ユーザーがブラウザのデータを消去したり、別のブラウザを使用したりすると、過去の進捗は失われる。
      * ランキングやソーシャル機能の実装不可: 中央集権的なデータベースが存在しないため、全ユーザーを対象としたランキングボードや対戦機能といった、リアルタイムの協調機能を実装することはできない。
